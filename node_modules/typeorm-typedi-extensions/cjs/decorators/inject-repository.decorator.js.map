{"version":3,"file":"inject-repository.decorator.js","sourceRoot":"","sources":["../../../src/decorators/inject-repository.decorator.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConnectionManager, Repository, TreeRepository, MongoRepository, EntityTarget, ObjectType } from 'typeorm';\nimport { Constructable, Container, ContainerInstance } from 'typedi';\n\nimport { EntityTypeMissingError } from '../errors/entity-type-missing.error';\nimport { PropertyTypeMissingError } from '../errors/property-type-missing.error';\nimport { ParamTypeMissingError } from '../errors/param-type-missing.error';\nimport { ConnectionNotFoundError } from '../errors/manager-not-found.error';\n\n/**\n * Helper to avoid V8 compilation of anonymous function on each call of decorator.\n */\nfunction getRepositoryHelper(\n  connectionName: string,\n  repositoryType: ObjectType<unknown>,\n  entityType: EntityTarget<unknown>,\n  containerInstance: ContainerInstance\n) {\n  const connectionManager = containerInstance.get(ConnectionManager);\n  if (!connectionManager.has(connectionName)) {\n    throw new ConnectionNotFoundError(connectionName);\n  }\n\n  const connection = connectionManager.get(connectionName);\n\n  switch (repositoryType) {\n    case Repository:\n      return connection.getRepository(entityType);\n    case MongoRepository:\n      return connection.getMongoRepository(entityType);\n    case TreeRepository:\n      return connection.getTreeRepository(entityType);\n    default:\n      /** If the requested type is not well-known, then it must be a custom repository. */\n      return connection.getCustomRepository(repositoryType);\n  }\n}\n\n/**\n * Injects the requested custom repository object using TypeDI's container. To make injection work without explicity\n * specifying the type in the decorator, you must annotate your properties and/or parameters with the correct type!\n *\n * ```ts\n * class SampleClass {\n *  \\@InjectRepository()\n *   userRepository: UserRepository;\n *\n *   constructor(@InjectRepository() private userRepository: UserRepository) {}\n * }\n * ```\n */\nexport function InjectRepository(): CallableFunction;\nexport function InjectRepository(connectionName: string): CallableFunction;\n\n/**\n * Injects the requested `Repository`, `MongoRepository`, `TreeRepository` object using TypeDI's container.\n * To make injection work without explicity specifying the type in the decorator, you must annotate your properties\n * and/or parameters with the correct type!\n *\n * ```ts\n * class SampleClass {\n *  \\@InjectRepository(User)\n *   userRepository: Repository<User>;\n *\n *   constructor(@InjectRepository(User) private userRepository: Repository<User>) {}\n * }\n * ```\n */\nexport function InjectRepository(entityType: Function): CallableFunction;\n/**\n * Injects the requested `Repository`, `MongoRepository`, `TreeRepository` object using TypeDI's container.\n * To make injection work without explicity specifying the type in the decorator, you must annotate your properties\n * and/or parameters with the correct type!\n *\n * ```ts\n * class SampleClass {\n *  \\@InjectRepository(User, \"test-conn\")\n *   userRepository: Repository<User>;\n *\n *   constructor(@InjectRepository(User, \"test-conn\") private userRepository: Repository<User>) {}\n * }\n * ```\n */\nexport function InjectRepository(entityType: Function, connectionName: string): CallableFunction;\nexport function InjectRepository(\n  entityTypeOrConnectionName?: Function | string,\n  paramConnectionName = 'default'\n): CallableFunction {\n  return (object: object, propertyName: string | symbol, index?: number): void => {\n    let entityType: Function | undefined;\n    let connectionName: string;\n    let repositoryType: Function;\n\n    // handle first parameter overload\n    connectionName = paramConnectionName;\n    if (typeof entityTypeOrConnectionName === 'string') {\n      connectionName = entityTypeOrConnectionName;\n    } else if (typeof entityTypeOrConnectionName === 'function') {\n      entityType = entityTypeOrConnectionName;\n    }\n\n    if (Reflect?.getOwnMetadata == undefined) {\n      throw new Error('Reflect.getOwnMetadata is not defined. Make sure to import the `reflect-metadata` package!');\n    }\n\n    if (index !== undefined) {\n      /** The decorator has been applied to a constructor parameter. */\n      const paramTypes: Function[] | undefined = Reflect.getOwnMetadata('design:paramtypes', object, propertyName);\n\n      if (!paramTypes || !paramTypes[index]) {\n        throw new ParamTypeMissingError(object, propertyName as string, index);\n      }\n\n      repositoryType = paramTypes[index];\n    } else {\n      /** The decorator has been applied to a class property. */\n      const propertyType: Function | undefined = Reflect.getOwnMetadata('design:type', object, propertyName);\n\n      if (!propertyType) {\n        throw new PropertyTypeMissingError(object, propertyName as string);\n      }\n\n      repositoryType = propertyType;\n    }\n\n    switch (repositoryType) {\n      case Repository:\n      case MongoRepository:\n      case TreeRepository:\n        if (!entityType) {\n          throw new EntityTypeMissingError(object, propertyName as string, index);\n        }\n    }\n\n    Container.registerHandler({\n      object: object as Constructable<unknown>,\n      index: index,\n      propertyName: propertyName as string,\n      value: containerInstance => getRepositoryHelper(connectionName, repositoryType, entityType!, containerInstance),\n    });\n  };\n}\n"]}